package com.github.copilot.client

import android.content.Context
import android.content.Intent
import android.content.SharedPreferences
import android.net.ConnectivityManager
import android.net.NetworkCapabilities
import android.os.Bundle
import android.util.Patterns
import android.view.Menu
import android.view.MenuItem
import android.view.View
import android.widget.ArrayAdapter
import android.widget.Toast
import androidx.activity.viewModels
import androidx.appcompat.app.AppCompatActivity
import androidx.core.widget.addTextChangedListener
import androidx.lifecycle.lifecycleScope
import androidx.preference.PreferenceManager
import com.github.copilot.client.databinding.ActivityMainBinding
import com.github.copilot.client.model.ServerConfig
import com.github.copilot.client.network.CopilotWebSocketClient
import com.github.copilot.client.network.NetworkScanner
import com.github.copilot.client.utils.StorageManager
import com.github.copilot.client.utils.ThemeManager
import com.github.copilot.client.utils.UpdateManager
import kotlinx.coroutines.launch
import java.util.Date

class MainActivity : AppCompatActivity() {
    
    private lateinit var binding: ActivityMainBinding
    private lateinit var preferences: SharedPreferences
    private lateinit var storageManager: StorageManager
    private lateinit var updateManager: UpdateManager
    private var webSocketClient: CopilotWebSocketClient? = null
    private var isConnected = false
    private var servers = mutableListOf<ServerConfig>()
    private var currentServer: ServerConfig? = null
    
    override fun onCreate(savedInstanceState: Bundle?) {
        // Apply theme before setting content view
        ThemeManager.applyTheme(this)
        
        super.onCreate(savedInstanceState)
        binding = ActivityMainBinding.inflate(layoutInflater)
        setContentView(binding.root)
        
        preferences = PreferenceManager.getDefaultSharedPreferences(this)
        storageManager = StorageManager(this)
        updateManager = UpdateManager(this)
        
        setupUI()
        loadServers()
        setupServerSpinner()
        observeConnectionState()
        checkForUpdatesIfNeeded()
        
        // Auto-connect if enabled and default server is available
        if (preferences.getBoolean("auto_connect", false)) {
            val currentServerId = storageManager.getCurrentServerId()
            if (currentServerId != null) {
                val server = servers.find { it.id == currentServerId }
                server?.let {
                    currentServer = it
                    updateServerSpinner()
                    connectToServer()
                }
            }
        }
    }
    
    override fun onCreateOptionsMenu(menu: Menu): Boolean {
        menuInflater.inflate(R.menu.main_menu, menu)
        return true
    }
    
    override fun onOptionsItemSelected(item: MenuItem): Boolean {
        return when (item.itemId) {
            R.id.action_settings -> {
                startActivity(Intent(this, SettingsActivity::class.java))
                true
            }
            R.id.action_help -> {
                startActivity(Intent(this, HelpActivity::class.java))
                true
            }
            R.id.action_servers -> {
                startActivity(Intent(this, ServerManagementActivity::class.java))
                true
            }
            else -> super.onOptionsItemSelected(item)
        }
    }
    
    private fun setupUI() {
        binding.apply {
            buttonConnect.setOnClickListener {
                if (isConnected) {
                    disconnectFromServer()
                } else {
                    connectToServer()
                }
            }
            
            buttonChat.setOnClickListener {
                startChatActivity()
            }
            
            buttonSettings.setOnClickListener {
                startActivity(Intent(this@MainActivity, SettingsActivity::class.java))
            }
            
            buttonTestLocalhost.setOnClickListener {
                testLocalhost()
            }
            
            buttonScanNetwork.setOnClickListener {
                scanNetwork()
            }
            
            // Server spinner selection
            spinnerServers.setOnItemSelectedListener(object : android.widget.AdapterView.OnItemSelectedListener {
                override fun onItemSelected(parent: android.widget.AdapterView<*>?, view: View?, position: Int, id: Long) {
                    if (servers.isNotEmpty() && position < servers.size) {
                        currentServer = servers[position]
                        storageManager.saveCurrentServerId(currentServer?.id)
                        updateConnectionUI()
                    }
                }
                
                override fun onNothingSelected(parent: android.widget.AdapterView<*>?) {}
            })
            
            // Quick add server button
            buttonAddServer.setOnClickListener {
                startActivity(Intent(this@MainActivity, ServerManagementActivity::class.java))
            }
            
            // Enable/disable connect button based on server selection
            updateConnectButtonState()
        }
    }
    
    private fun loadServers() {
        lifecycleScope.launch {
            servers.clear()
            servers.addAll(storageManager.loadServers())
            
            // Set current server
            val currentServerId = storageManager.getCurrentServerId()
            currentServer = servers.find { it.id == currentServerId } ?: servers.firstOrNull { it.isDefault }
            
            updateServerSpinner()
            updateConnectionUI()
        }
    }
    
    private fun setupServerSpinner() {
        val adapter = ArrayAdapter<String>(this, android.R.layout.simple_spinner_item)
        adapter.setDropDownViewResource(android.R.layout.simple_spinner_dropdown_item)
        binding.spinnerServers.adapter = adapter
    }
    
    private fun updateServerSpinner() {
        val adapter = binding.spinnerServers.adapter as ArrayAdapter<String>
        adapter.clear()
        
        servers.forEach { server ->
            val displayName = if (server.isDefault) "${server.name} (Default)" else server.name
            adapter.add(displayName)
        }
        
        // Select current server
        currentServer?.let { current ->
            val position = servers.indexOfFirst { it.id == current.id }
            if (position >= 0) {
                binding.spinnerServers.setSelection(position)
            }
        }
        
        adapter.notifyDataSetChanged()
        updateEmptyState()
    }
    
    private fun updateEmptyState() {
        binding.apply {
            if (servers.isEmpty()) {
                layoutServerSelection.visibility = View.GONE
                layoutEmptyState.visibility = View.VISIBLE
                buttonConnect.isEnabled = false
            } else {
                layoutServerSelection.visibility = View.VISIBLE
                layoutEmptyState.visibility = View.GONE
                updateConnectButtonState()
            }
        }
    }
    
    private fun updateConnectionUI() {
        currentServer?.let { server ->
            binding.textServerInfo.text = "Server: ${server.name}\nURL: ${server.url}"
        } ?: run {
            binding.textServerInfo.text = "No server selected"
        }
    }
    
    private fun updateConnectButtonState() {
        binding.buttonConnect.isEnabled = currentServer != null && !binding.textViewStatus.text.toString().contains("onnecting")
    }
    
    private fun testLocalhost() {
        // Create a temporary localhost server for testing
        val testServer = ServerConfig(
            name = "Localhost Test",
            url = "ws://localhost:3002",
            isDefault = false
        )
        
        servers.add(0, testServer)
        currentServer = testServer
        updateServerSpinner()
        updateConnectionUI()
        
        Toast.makeText(this, "Added localhost test server - make sure server is running locally", Toast.LENGTH_SHORT).show()
    }
    
    private fun scanNetwork() {
        if (!isNetworkAvailable()) {
            Toast.makeText(this, getString(R.string.error_network_unavailable), Toast.LENGTH_SHORT).show()
            return
        }
        
        // Show scanning progress
        binding.textViewStatus.text = "Scanning network..."
        
        lifecycleScope.launch {
            try {
                val scanner = NetworkScanner()
                val foundServers = scanner.scanForCopilotServers()
                
                if (foundServers.isNotEmpty()) {
                    showFoundServersDialog(foundServers)
                } else {
                    binding.textViewStatus.text = "No servers found on network"
                    Toast.makeText(this@MainActivity, "No Copilot servers found on local network", Toast.LENGTH_LONG).show()
                }
            } catch (e: Exception) {
                binding.textViewStatus.text = "Scan failed: ${e.message}"
                Toast.makeText(this@MainActivity, "Network scan failed: ${e.message}", Toast.LENGTH_LONG).show()
            }
        }
    }
    
    private fun showFoundServersDialog(foundServers: List<String>) {
        val items = foundServers.toTypedArray()
        androidx.appcompat.app.AlertDialog.Builder(this)
            .setTitle("Found Servers")
            .setItems(items) { _, which ->
                val selectedUrl = foundServers[which]
                
                // Create server config from found URL
                val serverName = "Found Server ${servers.size + 1}"
                val newServer = ServerConfig(
                    name = serverName,
                    url = selectedUrl,
                    isDefault = servers.isEmpty()
                )
                
                servers.add(newServer)
                currentServer = newServer
                storageManager.saveServers(servers)
                storageManager.saveCurrentServerId(newServer.id)
                
                updateServerSpinner()
                updateConnectionUI()
                
                Toast.makeText(this, "Server added: $serverName", Toast.LENGTH_SHORT).show()
            }
            .setNegativeButton("Cancel", null)
            .show()
    }
    
    private fun connectToServer() {
        val server = currentServer
        if (server == null) {
            Toast.makeText(this, "No server selected", Toast.LENGTH_SHORT).show()
            return
        }
        
        if (!isValidWebSocketUrl(server.url)) {
            Toast.makeText(this, "Invalid server URL format", Toast.LENGTH_SHORT).show()
            return
        }
        
        if (!isNetworkAvailable()) {
            Toast.makeText(this, getString(R.string.error_network_unavailable), Toast.LENGTH_SHORT).show()
            return
        }
        
        binding.textViewStatus.text = "Connecting to ${server.name}..."
        binding.buttonConnect.isEnabled = false
        
        lifecycleScope.launch {
            try {
                // Update last used time
                val updatedServer = server.copy(lastUsed = Date())
                val serverIndex = servers.indexOfFirst { it.id == server.id }
                if (serverIndex >= 0) {
                    servers[serverIndex] = updatedServer
                    currentServer = updatedServer
                    storageManager.saveServers(servers)
                }
                
                webSocketClient = CopilotWebSocketClient()
                val success = webSocketClient?.connect(server.url, server.apiKey) ?: false
                
                if (success) {
                    isConnected = true
                    binding.textViewStatus.text = "Connected to ${server.name} ✓"
                    binding.buttonConnect.text = "Disconnect"
                    binding.buttonChat.isEnabled = true
                    
                    Toast.makeText(this@MainActivity, "Connected successfully!", Toast.LENGTH_SHORT).show()
                } else {
                    throw Exception("Connection failed")
                }
                
            } catch (e: Exception) {
                binding.textViewStatus.text = "Connection failed: ${e.message}"
                Toast.makeText(this@MainActivity, "Connection failed: ${e.message}", Toast.LENGTH_LONG).show()
            } finally {
                binding.buttonConnect.isEnabled = true
            }
        }
    }
    
    private fun disconnectFromServer() {
        webSocketClient?.disconnect()
        webSocketClient = null
        isConnected = false
        
        binding.textViewStatus.text = "Disconnected"
        binding.buttonConnect.text = "Connect"
        binding.buttonChat.isEnabled = false
        updateConnectButtonState()
    }
    
    private fun startChatActivity() {
        if (isConnected && currentServer != null) {
            val intent = Intent(this, ChatActivity::class.java).apply {
                putExtra("server_id", currentServer!!.id)
                putExtra("server_name", currentServer!!.name)
            }
            startActivity(intent)
        } else {
            Toast.makeText(this, "Please connect to a server first", Toast.LENGTH_SHORT).show()
        }
    }
    
    private fun checkForUpdatesIfNeeded() {
        if (UpdateManager.shouldCheckForUpdates(this)) {
            lifecycleScope.launch {
                val updateInfo = updateManager.checkForUpdates()
                if (updateInfo != null) {
                    val skipVersion = UpdateManager.getSkipVersion(this@MainActivity)
                    if (skipVersion != updateInfo.version) {
                        showUpdateNotification(updateInfo)
                    }
                }
                UpdateManager.markUpdateChecked(this@MainActivity)
            }
        }
    }
    
    private fun showUpdateNotification(updateInfo: com.github.copilot.client.model.UpdateInfo) {
        androidx.appcompat.app.AlertDialog.Builder(this)
            .setTitle("Update Available")
            .setMessage("Version ${updateInfo.version} is available. Would you like to download it?")
            .setPositiveButton("Download") { _, _ ->
                val intent = updateManager.getDownloadIntent(updateInfo.downloadUrl)
                startActivity(intent)
            }
            .setNegativeButton("Later", null)
            .setNeutralButton("Skip This Version") { _, _ ->
                UpdateManager.setSkipVersion(this, updateInfo.version)
            }
            .show()
    }
    
    override fun onResume() {
        super.onResume()
        loadServers() // Reload servers in case they were modified in settings
    }
    
    private fun observeConnectionState() {
        // Observe connection state changes
        lifecycleScope.launch {
            // Connection state observation logic would go here
            // This would typically observe a ViewModel or LiveData
        }
    }
    
    private fun isValidWebSocketUrl(url: String): Boolean {
        return url.startsWith("ws://") || url.startsWith("wss://") || 
               (url.startsWith("http") && Patterns.WEB_URL.matcher(url).matches())
    }
    
    private fun isNetworkAvailable(): Boolean {
        val connectivityManager = getSystemService(Context.CONNECTIVITY_SERVICE) as ConnectivityManager
        val network = connectivityManager.activeNetwork ?: return false
        val networkCapabilities = connectivityManager.getNetworkCapabilities(network) ?: return false
        return networkCapabilities.hasCapability(NetworkCapabilities.NET_CAPABILITY_INTERNET)
    }
}
            
            editTextApiKey.addTextChangedListener {
                saveServerSettings()
            }
        }
    }
    
    private fun loadSavedSettings() {
        val savedUrl = preferences.getString(getString(R.string.pref_server_url), "")
        val savedApiKey = preferences.getString(getString(R.string.pref_api_key), "")
        
        binding.editTextServerUrl.setText(savedUrl)
        binding.editTextApiKey.setText(savedApiKey)
        
        updateConnectButtonState()
    }
    
    private fun saveServerSettings() {
        val url = binding.editTextServerUrl.text.toString().trim()
        val apiKey = binding.editTextApiKey.text.toString().trim()
        
        preferences.edit()
            .putString(getString(R.string.pref_server_url), url)
            .putString(getString(R.string.pref_api_key), apiKey)
            .apply()
    }
    
    private fun updateConnectButtonState() {
        val url = binding.editTextServerUrl.text.toString().trim()
        binding.buttonConnect.isEnabled = url.isNotEmpty() && !binding.textViewStatus.text.toString().contains("onnecting")
    }
    
    private fun testLocalhost() {
        binding.editTextServerUrl.setText("ws://localhost:3001")
        Toast.makeText(this, "Set to localhost - make sure server is running locally", Toast.LENGTH_SHORT).show()
    }
    
    private fun scanNetwork() {
        if (!isNetworkAvailable()) {
            Toast.makeText(this, getString(R.string.error_network_unavailable), Toast.LENGTH_SHORT).show()
            return
        }
        
        binding.textViewStatus.text = getString(R.string.scanning_network)
        binding.textViewStatus.setTextColor(getColor(R.color.status_connecting))
        
        lifecycleScope.launch {
            try {
                val networkScanner = NetworkScanner()
                val servers = networkScanner.scanForServers()
                
                runOnUiThread {
                    if (servers.isNotEmpty()) {
                        val serverUrl = servers.first()
                        binding.editTextServerUrl.setText(serverUrl)
                        Toast.makeText(this@MainActivity, 
                            getString(R.string.servers_found, servers.size), 
                            Toast.LENGTH_SHORT).show()
                    } else {
                        Toast.makeText(this@MainActivity, 
                            getString(R.string.no_servers_found), 
                            Toast.LENGTH_SHORT).show()
                    }
                    updateConnectionStatusUI(CopilotWebSocketClient.ConnectionState.DISCONNECTED)
                }
            } catch (e: Exception) {
                runOnUiThread {
                    Toast.makeText(this@MainActivity, "Network scan failed: ${e.message}", Toast.LENGTH_SHORT).show()
                    updateConnectionStatusUI(CopilotWebSocketClient.ConnectionState.DISCONNECTED)
                }
            }
        }
    }
    
    private fun connectToServer() {
        val url = binding.editTextServerUrl.text.toString().trim()
        val apiKey = binding.editTextApiKey.text.toString().trim().takeIf { it.isNotEmpty() }
        
        if (!isValidWebSocketUrl(url)) {
            Toast.makeText(this, getString(R.string.invalid_url), Toast.LENGTH_SHORT).show()
            return
        }
        
        if (!isNetworkAvailable()) {
            Toast.makeText(this, getString(R.string.error_network_unavailable), Toast.LENGTH_SHORT).show()
            return
        }
        
        // Save settings before connecting
        saveServerSettings()
        
        // Update UI to show connecting state
        updateConnectionStatusUI(CopilotWebSocketClient.ConnectionState.CONNECTING)
        
        // Create and connect WebSocket client
        webSocketClient = CopilotWebSocketClient(url, apiKey)
        
        // Connect in background
        lifecycleScope.launch {
            try {
                webSocketClient?.connect()
            } catch (e: Exception) {
                runOnUiThread {
                    showConnectionError(e.message ?: "Unknown error")
                }
            }
        }
    }
    
    private fun disconnectFromServer() {
        updateConnectionStatusUI(CopilotWebSocketClient.ConnectionState.DISCONNECTED)
        webSocketClient?.disconnect()
        webSocketClient = null
        isConnected = false
    }
    
    private fun observeConnectionState() {
        lifecycleScope.launch {
            webSocketClient?.connectionState?.collect { state ->
                runOnUiThread {
                    updateConnectionStatusUI(state)
                }
            }
        }
        
        lifecycleScope.launch {
            webSocketClient?.errors?.collect { error ->
                error?.let {
                    runOnUiThread {
                        showConnectionError(it)
                    }
                }
            }
        }
    }
    
    private fun updateConnectionStatusUI(state: CopilotWebSocketClient.ConnectionState) {
        binding.apply {
            when (state) {
                CopilotWebSocketClient.ConnectionState.CONNECTING -> {
                    textViewStatus.text = getString(R.string.connecting)
                    textViewStatus.setTextColor(getColor(R.color.status_connecting))
                    buttonConnect.isEnabled = false
                    buttonChat.isEnabled = false
                    isConnected = false
                }
                CopilotWebSocketClient.ConnectionState.CONNECTED -> {
                    textViewStatus.text = getString(R.string.connected)
                    textViewStatus.setTextColor(getColor(R.color.status_connected))
                    buttonConnect.isEnabled = true
                    buttonConnect.text = getString(R.string.disconnect)
                    buttonChat.isEnabled = true
                    isConnected = true
                    Toast.makeText(this@MainActivity, "Successfully connected to server!", Toast.LENGTH_SHORT).show()
                }
                CopilotWebSocketClient.ConnectionState.DISCONNECTED -> {
                    textViewStatus.text = getString(R.string.not_connected)
                    textViewStatus.setTextColor(getColor(R.color.status_disconnected))
                    buttonConnect.isEnabled = true
                    buttonConnect.text = getString(R.string.connect_to_server)
                    buttonChat.isEnabled = false
                    isConnected = false
                }
                CopilotWebSocketClient.ConnectionState.ERROR -> {
                    textViewStatus.text = getString(R.string.connection_failed)
                    textViewStatus.setTextColor(getColor(R.color.status_disconnected))
                    buttonConnect.isEnabled = true
                    buttonConnect.text = getString(R.string.connect_to_server)
                    buttonChat.isEnabled = false
                    isConnected = false
                }
            }
        }
    }
    
    private fun showConnectionError(error: String) {
        Toast.makeText(this, "Connection error: $error", Toast.LENGTH_LONG).show()
        updateConnectionStatusUI(CopilotWebSocketClient.ConnectionState.ERROR)
    }
    
    private fun startChatActivity() {
        val intent = Intent(this, ChatActivity::class.java)
        ChatActivity.webSocketClient = webSocketClient
        startActivity(intent)
    }
    
    private fun isValidWebSocketUrl(url: String): Boolean {
        return (url.startsWith("ws://") || url.startsWith("wss://")) && 
               Patterns.WEB_URL.matcher(url.replace("ws://", "http://").replace("wss://", "https://")).matches()
    }
    
    private fun isNetworkAvailable(): Boolean {
        val connectivityManager = getSystemService(Context.CONNECTIVITY_SERVICE) as ConnectivityManager
        val network = connectivityManager.activeNetwork ?: return false
        val capabilities = connectivityManager.getNetworkCapabilities(network) ?: return false
        return capabilities.hasTransport(NetworkCapabilities.TRANSPORT_WIFI) || 
               capabilities.hasTransport(NetworkCapabilities.TRANSPORT_CELLULAR)
    }
    
    override fun onDestroy() {
        super.onDestroy()
        // Don't disconnect here to allow background connection
    }
    
    override fun onResume() {
        super.onResume()
        // Reload settings in case they were changed in SettingsActivity
        loadSavedSettings()
        
        // Re-observe connection state if client exists
        webSocketClient?.let {
            observeConnectionState()
        }
    }
}